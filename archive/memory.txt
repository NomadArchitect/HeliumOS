Physical memory manager:
  Features:
    - Allocate regions from physical address space, with a size hint
    - Free regions of the physical address space previously allocated
    - Prefers higher addresses when no constraints are forced
    - Constraints:
      - Continuous region(Treat size as a must, not a hint)
      - Maximum address(The region should be below a certain address)
  
  Implementation:
    Initialization
      - Store bootboot's memory map backwards in a buffer
        Backwards, because bootboot sorts the memory map by address
        If we store it backwards, the allocator will naturally prefer
        higher addresses whem allocating
      - Find a region in physical space large enough to hold that buffer + bitmaps
      - The bitmap is an array of u64
      - Subtract the size of the buffer + bitmaps from the size of the region
      - Call that region pheader
      - Initialize the bitmaps to 0s(except leftover pages, to 1s)
      - Copy the buffer + bitmaps to pheader
    
    Allocation:
      - Traverse the memory map found in pheader and find a region that is below the maximum address if requested
        - Travers that region's bitmap and find a free page that is still below the maximum address if requested
          - Count how many free pages are after this one until the requested size or a used page is reached
          - If the request was for a continuous region and size was reached, or if the request wasnt for a continuous region
            - Then mark the pages as used and return a mem_pallocation structure containing:
              - the offset of the region's header after pheader
              - The physical address marking the start of the allocated region
              - the size of the actually allocated region(Could be different than the requested size, even if continuous pages are requested)
          - Otherwise, find next free page and loop again
      - If no region meeting the contraints are found, return a mem_pallocation with all fields set to 0
    Deallocation:
      - Takes a mem_pallocation returned from the allocation algorithm as input
      - Go to the region header found at pheader + offset in mem_pallocation
      - Mark the pages starting from the physical address in mem_pallocation to the size as free pages
  
  Interface:
    - struct mem_pallocation { header_off, padr, size }
    - func mem_ppaloc(pheader, size, continuous : bool, below : ptr) : mem_pallocation
    - func mem_ppfree(pheader, alloc : mem_pallocation) : void


Virtual memory manager:
  Features:
    - Map a region from virtual address space to a region from physical address space
    - Set permissions for a certain virtual address space
    - Support 4K, 2M and 1G pages
  Implementation:
    Concepts:
      Order of a paging structure:
        Each paging structure is assigned an order:
          - PML4: order 3
          - PDPT: order 2
          - PDT : order 1
          - PT  : order 0
        These orders can be used to so some useful math when trying to figure out some offsets later
      
      Notations:
        - The index of the entry in a structure of order n that maps a virtual address ptr is written as ENTRY_IDX(n, ptr)
          ENTRY_IDX bit range in ptr whose limits can be calculated with the order(The exact math is in src/mem/internal_mem.h)
      
      Virtual memory manager structure:
        Starting at address VMM_STRUCT_PTR in the virtual address space

# Implemented features

Nothing yet :/

# Features intended for the long run
## File system
For the file system, I am planning to combine both the unix way and windows way of doing things

I find file systems being mounted on folders inside other file systems a little bit stupid, although clever, not really obvious to someone not familiar with such system, for this reason, file systems will be very similar to windows'. One difference tho would be the names, instead of naming file systems C or D, we would have descriptive name depending on what the fs communicates with

One thing I'll borrow from unix tho is the everything is a file convention

As the os will be written in a modular way, I'd like to allow each module to register its own fs commands, a general format of a file on disk full path might look like this:

`disk_name:partition_name:/folder/subfolder/file`

files shouldn't necessarily be on disk of course, like unix, files can be just a representation of a system exposed variable, take the following path as example:

`system:/uptime`

that path may be just a link to a variable stored on memory in the kernel's section storing the uptime

When the OS receives a file operation syscall (be it read, write, create, delete...), that path is first is passed the a module called masterfs, this module will read what comes before the first `:`, that text is called *the command*, each other module can register as many commands as it wants, the term *command* isn't to be taken literally tho, for example, a disk read/write module might register a command for each disk connected to the system, for this reason the masterfs module should allow commands to be registered at any time not only at boot time. A *core* module might also register the command *system* which would allow the access to some system exposed variables. Modules that wish to register fs commands however should implement some functions to handle different file operations, this isn't decisive, but I am thinking for a set of functions like this:

`read(string command, list<string> subcommands, list<string> folders, string file)`

`write(string command, list<string> subcommands, list<string> folders, string file, ptr buf, size_type size)`

...

The set of arguments `(string command, list<string> subcommands, list<string> folders, string file)` will be generated by masterfs module from the path.

Do note that sub commands are not kept track of by masterfs, they are completely interpreted by the called module. For example a disk module might only accept one additional sub command which it would interpret as the partition name, the system command would for example return an error if any additional sub command is passed onto it...

There might come a problem when two modules decided to register commands with similar names, for example the *core* module registers the command *system* at boot time, then the *disk* module registers the same command with the name *system* because a disk with that name was inserted after boot time, the solution for this is the allow the following syntax:

`(module_name)command:sub_commands:/folder/subfolder/file`

So in the example of that unlucky disk by the name *system*, we could have:

`(core)system:/uptime`

`(disk)system:partition_name:/`

This solution isn't complete yet, what if the user now only inputs `system` as the command name, without specifying what module should take it? The laziest solution would be to just return a file not found or some other kind of error to the user when we have an ambiguous file path. But that would kind of ruin everything, the command `system` is a defining feature of the os, it would be stupid to not be able to access it because a disk decided to be called like that. This is why I thought about making commands when they are registered should pass another argument, whether they are necessary or contingent(Maybe call them something else? Not everyone is familiar with philosophical terms), if you aren't familiar with those philosophical terms, contingent means it could have been otherwise, in the example, that disk could have been called potato, or anything else, but it happened to be system, while the system command defined by the core module could only have had that name when registered, it's name wasn't dependent on something outside of the kernel that could have had another name, it was hardcoded to be called system. masterfs will only allow one command with a certain name to be necessary, if other commands with the same name register themselves as necessary later, then masterfs will make them contingent. The modules included with HeliumOS by default should never have necessary commands with clashing names tho.
Going back to the point, the core module will register the command system as necessary, while the disk module will register all its disks as contingent commands, including any disk possibly called system, if the user specify the command system without specifying the module, masterfs will give priority to the necessary command first.
